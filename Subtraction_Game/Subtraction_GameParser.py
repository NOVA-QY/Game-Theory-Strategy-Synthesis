# Generated from Subtraction_Game.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3A")
        buf.write("\u01e3\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\3\2\3\2\3\2\3\2\3\2\3\2")
        buf.write("\3\2\3\2\3\2\3\2\7\2O\n\2\f\2\16\2R\13\2\3\2\3\2\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\6\4`\n\4\r\4\16\4a")
        buf.write("\3\4\3\4\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\5\6r\n\6\3\7\3\7\3\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\6")
        buf.write("\b~\n\b\r\b\16\b\177\3\b\3\b\3\t\3\t\3\t\3\t\5\t\u0088")
        buf.write("\n\t\3\t\3\t\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3\13\3\13")
        buf.write("\5\13\u0095\n\13\3\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3")
        buf.write("\r\3\r\3\r\5\r\u00a3\n\r\3\r\3\r\3\r\5\r\u00a8\n\r\3\r")
        buf.write("\3\r\3\r\5\r\u00ad\n\r\3\r\3\r\3\16\3\16\3\17\3\17\3\17")
        buf.write("\5\17\u00b6\n\17\3\20\3\20\3\20\5\20\u00bb\n\20\3\21\7")
        buf.write("\21\u00be\n\21\f\21\16\21\u00c1\13\21\3\21\6\21\u00c4")
        buf.write("\n\21\r\21\16\21\u00c5\3\21\3\21\3\21\3\21\5\21\u00cc")
        buf.write("\n\21\3\22\7\22\u00cf\n\22\f\22\16\22\u00d2\13\22\3\22")
        buf.write("\6\22\u00d5\n\22\r\22\16\22\u00d6\3\22\3\22\3\22\3\22")
        buf.write("\5\22\u00dd\n\22\3\23\3\23\6\23\u00e1\n\23\r\23\16\23")
        buf.write("\u00e2\3\24\3\24\3\24\3\24\6\24\u00e9\n\24\r\24\16\24")
        buf.write("\u00ea\3\24\3\24\3\24\3\24\3\24\6\24\u00f2\n\24\r\24\16")
        buf.write("\24\u00f3\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\5\24\u0113")
        buf.write("\n\24\3\25\3\25\3\25\7\25\u0118\n\25\f\25\16\25\u011b")
        buf.write("\13\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3")
        buf.write("\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\3\25\3\25\3\25\3\25\3\25\3\25\5\25\u0143\n\25\3")
        buf.write("\26\3\26\3\26\3\26\3\26\3\26\5\26\u014b\n\26\3\27\3\27")
        buf.write("\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27")
        buf.write("\3\27\3\27\3\27\3\27\3\27\3\27\5\27\u0160\n\27\3\30\3")
        buf.write("\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30")
        buf.write("\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\5\30\u0176\n")
        buf.write("\30\3\31\3\31\3\31\6\31\u017b\n\31\r\31\16\31\u017c\3")
        buf.write("\31\3\31\3\31\5\31\u0182\n\31\3\32\3\32\3\33\3\33\3\33")
        buf.write("\3\33\3\33\3\33\3\34\3\34\3\35\3\35\3\36\3\36\3\36\3\36")
        buf.write("\6\36\u0194\n\36\r\36\16\36\u0195\3\36\3\36\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\3 \3 \3 \3 \3 \3 \3 \3 \6 \u01a8")
        buf.write("\n \r \16 \u01a9\3 \3 \3!\3!\3!\3!\7!\u01b2\n!\f!\16!")
        buf.write("\u01b5\13!\3!\3!\3\"\3\"\3\"\7\"\u01bc\n\"\f\"\16\"\u01bf")
        buf.write("\13\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"")
        buf.write("\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write("\"\3\"\3\"\3\"\3\"\3\"\3\"\5\"\u01e1\n\"\3\"\2\2#\2\4")
        buf.write("\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64")
        buf.write("\668:<>@B\2\4\5\2\32\32\36\36==\3\2\33\35\2\u01f7\2D\3")
        buf.write("\2\2\2\4U\3\2\2\2\6[\3\2\2\2\be\3\2\2\2\nq\3\2\2\2\fs")
        buf.write("\3\2\2\2\16y\3\2\2\2\20\u0083\3\2\2\2\22\u008b\3\2\2\2")
        buf.write("\24\u0094\3\2\2\2\26\u0096\3\2\2\2\30\u0098\3\2\2\2\32")
        buf.write("\u00b0\3\2\2\2\34\u00b5\3\2\2\2\36\u00ba\3\2\2\2 \u00cb")
        buf.write("\3\2\2\2\"\u00dc\3\2\2\2$\u00de\3\2\2\2&\u0112\3\2\2\2")
        buf.write("(\u0142\3\2\2\2*\u014a\3\2\2\2,\u015f\3\2\2\2.\u0175\3")
        buf.write("\2\2\2\60\u0181\3\2\2\2\62\u0183\3\2\2\2\64\u0185\3\2")
        buf.write("\2\2\66\u018b\3\2\2\28\u018d\3\2\2\2:\u018f\3\2\2\2<\u0199")
        buf.write("\3\2\2\2>\u019f\3\2\2\2@\u01ad\3\2\2\2B\u01e0\3\2\2\2")
        buf.write("DE\7#\2\2EF\7\5\2\2FG\7#\2\2GH\7\3\2\2HI\7=\2\2IJ\7$\2")
        buf.write("\2JK\5\4\3\2KL\5\n\6\2LP\5\f\7\2MO\5\30\r\2NM\3\2\2\2")
        buf.write("OR\3\2\2\2PN\3\2\2\2PQ\3\2\2\2QS\3\2\2\2RP\3\2\2\2ST\7")
        buf.write("$\2\2T\3\3\2\2\2UV\7#\2\2VW\7\'\2\2WX\7 \2\2XY\5\"\22")
        buf.write("\2YZ\7$\2\2Z\5\3\2\2\2[\\\7#\2\2\\]\7\'\2\2]_\7\26\2\2")
        buf.write("^`\5\b\5\2_^\3\2\2\2`a\3\2\2\2a_\3\2\2\2ab\3\2\2\2bc\3")
        buf.write("\2\2\2cd\7$\2\2d\7\3\2\2\2ef\7=\2\2f\t\3\2\2\2gh\7#\2")
        buf.write("\2hi\7\'\2\2ij\7\b\2\2jk\7\27\2\2kr\7$\2\2lm\7#\2\2mn")
        buf.write("\7\'\2\2no\7\b\2\2op\7\30\2\2pr\7$\2\2qg\3\2\2\2ql\3\2")
        buf.write("\2\2r\13\3\2\2\2st\7#\2\2tu\7\'\2\2uv\7\20\2\2vw\5\34")
        buf.write("\17\2wx\7$\2\2x\r\3\2\2\2yz\7#\2\2z{\7\'\2\2{}\7\t\2\2")
        buf.write("|~\5\20\t\2}|\3\2\2\2~\177\3\2\2\2\177}\3\2\2\2\177\u0080")
        buf.write("\3\2\2\2\u0080\u0081\3\2\2\2\u0081\u0082\7$\2\2\u0082")
        buf.write("\17\3\2\2\2\u0083\u0084\7#\2\2\u0084\u0085\5\22\n\2\u0085")
        buf.write("\u0087\5\"\22\2\u0086\u0088\5$\23\2\u0087\u0086\3\2\2")
        buf.write("\2\u0087\u0088\3\2\2\2\u0088\u0089\3\2\2\2\u0089\u008a")
        buf.write("\7$\2\2\u008a\21\3\2\2\2\u008b\u008c\7=\2\2\u008c\23\3")
        buf.write("\2\2\2\u008d\u0095\7=\2\2\u008e\u008f\7#\2\2\u008f\u0090")
        buf.write("\7=\2\2\u0090\u0091\5,\27\2\u0091\u0092\5,\27\2\u0092")
        buf.write("\u0093\7$\2\2\u0093\u0095\3\2\2\2\u0094\u008d\3\2\2\2")
        buf.write("\u0094\u008e\3\2\2\2\u0095\25\3\2\2\2\u0096\u0097\t\2")
        buf.write("\2\2\u0097\27\3\2\2\2\u0098\u0099\7#\2\2\u0099\u009a\7")
        buf.write("\'\2\2\u009a\u009b\7\n\2\2\u009b\u00a2\5\32\16\2\u009c")
        buf.write("\u009d\7\'\2\2\u009d\u009e\7\17\2\2\u009e\u009f\7#\2\2")
        buf.write("\u009f\u00a0\5\"\22\2\u00a0\u00a1\7$\2\2\u00a1\u00a3\3")
        buf.write("\2\2\2\u00a2\u009c\3\2\2\2\u00a2\u00a3\3\2\2\2\u00a3\u00a7")
        buf.write("\3\2\2\2\u00a4\u00a5\7\'\2\2\u00a5\u00a6\7\21\2\2\u00a6")
        buf.write("\u00a8\5\34\17\2\u00a7\u00a4\3\2\2\2\u00a7\u00a8\3\2\2")
        buf.write("\2\u00a8\u00ac\3\2\2\2\u00a9\u00aa\7\'\2\2\u00aa\u00ab")
        buf.write("\7\31\2\2\u00ab\u00ad\5\36\20\2\u00ac\u00a9\3\2\2\2\u00ac")
        buf.write("\u00ad\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae\u00af\7$\2\2")
        buf.write("\u00af\31\3\2\2\2\u00b0\u00b1\7=\2\2\u00b1\33\3\2\2\2")
        buf.write("\u00b2\u00b6\5&\24\2\u00b3\u00b4\7#\2\2\u00b4\u00b6\7")
        buf.write("$\2\2\u00b5\u00b2\3\2\2\2\u00b5\u00b3\3\2\2\2\u00b6\35")
        buf.write("\3\2\2\2\u00b7\u00bb\5\60\31\2\u00b8\u00b9\7#\2\2\u00b9")
        buf.write("\u00bb\7$\2\2\u00ba\u00b7\3\2\2\2\u00ba\u00b8\3\2\2\2")
        buf.write("\u00bb\37\3\2\2\2\u00bc\u00be\7=\2\2\u00bd\u00bc\3\2\2")
        buf.write("\2\u00be\u00c1\3\2\2\2\u00bf\u00bd\3\2\2\2\u00bf\u00c0")
        buf.write("\3\2\2\2\u00c0\u00cc\3\2\2\2\u00c1\u00bf\3\2\2\2\u00c2")
        buf.write("\u00c4\7=\2\2\u00c3\u00c2\3\2\2\2\u00c4\u00c5\3\2\2\2")
        buf.write("\u00c5\u00c3\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6\u00c7\3")
        buf.write("\2\2\2\u00c7\u00c8\7+\2\2\u00c8\u00c9\5\26\f\2\u00c9\u00ca")
        buf.write("\5 \21\2\u00ca\u00cc\3\2\2\2\u00cb\u00bf\3\2\2\2\u00cb")
        buf.write("\u00c3\3\2\2\2\u00cc!\3\2\2\2\u00cd\u00cf\7?\2\2\u00ce")
        buf.write("\u00cd\3\2\2\2\u00cf\u00d2\3\2\2\2\u00d0\u00ce\3\2\2\2")
        buf.write("\u00d0\u00d1\3\2\2\2\u00d1\u00dd\3\2\2\2\u00d2\u00d0\3")
        buf.write("\2\2\2\u00d3\u00d5\7?\2\2\u00d4\u00d3\3\2\2\2\u00d5\u00d6")
        buf.write("\3\2\2\2\u00d6\u00d4\3\2\2\2\u00d6\u00d7\3\2\2\2\u00d7")
        buf.write("\u00d8\3\2\2\2\u00d8\u00d9\7+\2\2\u00d9\u00da\5\26\f\2")
        buf.write("\u00da\u00db\5\"\22\2\u00db\u00dd\3\2\2\2\u00dc\u00d0")
        buf.write("\3\2\2\2\u00dc\u00d4\3\2\2\2\u00dd#\3\2\2\2\u00de\u00e0")
        buf.write("\78\2\2\u00df\u00e1\7?\2\2\u00e0\u00df\3\2\2\2\u00e1\u00e2")
        buf.write("\3\2\2\2\u00e2\u00e0\3\2\2\2\u00e2\u00e3\3\2\2\2\u00e3")
        buf.write("%\3\2\2\2\u00e4\u0113\5(\25\2\u00e5\u00e6\7#\2\2\u00e6")
        buf.write("\u00e8\7\65\2\2\u00e7\u00e9\5&\24\2\u00e8\u00e7\3\2\2")
        buf.write("\2\u00e9\u00ea\3\2\2\2\u00ea\u00e8\3\2\2\2\u00ea\u00eb")
        buf.write("\3\2\2\2\u00eb\u00ec\3\2\2\2\u00ec\u00ed\7$\2\2\u00ed")
        buf.write("\u0113\3\2\2\2\u00ee\u00ef\7#\2\2\u00ef\u00f1\7\66\2\2")
        buf.write("\u00f0\u00f2\5&\24\2\u00f1\u00f0\3\2\2\2\u00f2\u00f3\3")
        buf.write("\2\2\2\u00f3\u00f1\3\2\2\2\u00f3\u00f4\3\2\2\2\u00f4\u00f5")
        buf.write("\3\2\2\2\u00f5\u00f6\7$\2\2\u00f6\u0113\3\2\2\2\u00f7")
        buf.write("\u00f8\7#\2\2\u00f8\u00f9\7\67\2\2\u00f9\u00fa\5&\24\2")
        buf.write("\u00fa\u00fb\7$\2\2\u00fb\u0113\3\2\2\2\u00fc\u00fd\7")
        buf.write("#\2\2\u00fd\u00fe\79\2\2\u00fe\u00ff\5&\24\2\u00ff\u0100")
        buf.write("\5&\24\2\u0100\u0101\7$\2\2\u0101\u0113\3\2\2\2\u0102")
        buf.write("\u0103\7#\2\2\u0103\u0104\7;\2\2\u0104\u0105\7#\2\2\u0105")
        buf.write("\u0106\5\"\22\2\u0106\u0107\7$\2\2\u0107\u0108\5&\24\2")
        buf.write("\u0108\u0109\7$\2\2\u0109\u0113\3\2\2\2\u010a\u010b\7")
        buf.write("#\2\2\u010b\u010c\7:\2\2\u010c\u010d\7#\2\2\u010d\u010e")
        buf.write("\5\"\22\2\u010e\u010f\7$\2\2\u010f\u0110\5&\24\2\u0110")
        buf.write("\u0111\7$\2\2\u0111\u0113\3\2\2\2\u0112\u00e4\3\2\2\2")
        buf.write("\u0112\u00e5\3\2\2\2\u0112\u00ee\3\2\2\2\u0112\u00f7\3")
        buf.write("\2\2\2\u0112\u00fc\3\2\2\2\u0112\u0102\3\2\2\2\u0112\u010a")
        buf.write("\3\2\2\2\u0113\'\3\2\2\2\u0114\u0115\7#\2\2\u0115\u0119")
        buf.write("\5\22\n\2\u0116\u0118\5.\30\2\u0117\u0116\3\2\2\2\u0118")
        buf.write("\u011b\3\2\2\2\u0119\u0117\3\2\2\2\u0119\u011a\3\2\2\2")
        buf.write("\u011a\u011c\3\2\2\2\u011b\u0119\3\2\2\2\u011c\u011d\7")
        buf.write("$\2\2\u011d\u0143\3\2\2\2\u011e\u011f\7#\2\2\u011f\u0120")
        buf.write("\7/\2\2\u0120\u0121\5.\30\2\u0121\u0122\5.\30\2\u0122")
        buf.write("\u0123\7$\2\2\u0123\u0143\3\2\2\2\u0124\u0125\7#\2\2\u0125")
        buf.write("\u0126\7\60\2\2\u0126\u0127\5.\30\2\u0127\u0128\5.\30")
        buf.write("\2\u0128\u0129\7$\2\2\u0129\u0143\3\2\2\2\u012a\u012b")
        buf.write("\7#\2\2\u012b\u012c\7\61\2\2\u012c\u012d\5.\30\2\u012d")
        buf.write("\u012e\5.\30\2\u012e\u012f\7$\2\2\u012f\u0143\3\2\2\2")
        buf.write("\u0130\u0131\7#\2\2\u0131\u0132\7\62\2\2\u0132\u0133\5")
        buf.write(".\30\2\u0133\u0134\5.\30\2\u0134\u0135\7$\2\2\u0135\u0143")
        buf.write("\3\2\2\2\u0136\u0137\7#\2\2\u0137\u0138\7\63\2\2\u0138")
        buf.write("\u0139\5.\30\2\u0139\u013a\5.\30\2\u013a\u013b\7$\2\2")
        buf.write("\u013b\u0143\3\2\2\2\u013c\u013d\7#\2\2\u013d\u013e\7")
        buf.write("\64\2\2\u013e\u013f\5.\30\2\u013f\u0140\5.\30\2\u0140")
        buf.write("\u0141\7$\2\2\u0141\u0143\3\2\2\2\u0142\u0114\3\2\2\2")
        buf.write("\u0142\u011e\3\2\2\2\u0142\u0124\3\2\2\2\u0142\u012a\3")
        buf.write("\2\2\2\u0142\u0130\3\2\2\2\u0142\u0136\3\2\2\2\u0142\u013c")
        buf.write("\3\2\2\2\u0143)\3\2\2\2\u0144\u014b\5(\25\2\u0145\u0146")
        buf.write("\7#\2\2\u0146\u0147\7\67\2\2\u0147\u0148\5(\25\2\u0148")
        buf.write("\u0149\7$\2\2\u0149\u014b\3\2\2\2\u014a\u0144\3\2\2\2")
        buf.write("\u014a\u0145\3\2\2\2\u014b+\3\2\2\2\u014c\u0160\7=\2\2")
        buf.write("\u014d\u0160\7>\2\2\u014e\u014f\7#\2\2\u014f\u0150\7+")
        buf.write("\2\2\u0150\u0151\5,\27\2\u0151\u0152\7$\2\2\u0152\u0160")
        buf.write("\3\2\2\2\u0153\u0154\7#\2\2\u0154\u0155\7+\2\2\u0155\u0156")
        buf.write("\5,\27\2\u0156\u0157\5,\27\2\u0157\u0158\7$\2\2\u0158")
        buf.write("\u0160\3\2\2\2\u0159\u015a\7#\2\2\u015a\u015b\7,\2\2\u015b")
        buf.write("\u015c\5,\27\2\u015c\u015d\5,\27\2\u015d\u015e\7$\2\2")
        buf.write("\u015e\u0160\3\2\2\2\u015f\u014c\3\2\2\2\u015f\u014d\3")
        buf.write("\2\2\2\u015f\u014e\3\2\2\2\u015f\u0153\3\2\2\2\u015f\u0159")
        buf.write("\3\2\2\2\u0160-\3\2\2\2\u0161\u0176\7=\2\2\u0162\u0176")
        buf.write("\7?\2\2\u0163\u0176\7>\2\2\u0164\u0165\7#\2\2\u0165\u0166")
        buf.write("\7+\2\2\u0166\u0167\5.\30\2\u0167\u0168\7$\2\2\u0168\u0176")
        buf.write("\3\2\2\2\u0169\u016a\7#\2\2\u016a\u016b\7+\2\2\u016b\u016c")
        buf.write("\5.\30\2\u016c\u016d\5.\30\2\u016d\u016e\7$\2\2\u016e")
        buf.write("\u0176\3\2\2\2\u016f\u0170\7#\2\2\u0170\u0171\7,\2\2\u0171")
        buf.write("\u0172\5.\30\2\u0172\u0173\5.\30\2\u0173\u0174\7$\2\2")
        buf.write("\u0174\u0176\3\2\2\2\u0175\u0161\3\2\2\2\u0175\u0162\3")
        buf.write("\2\2\2\u0175\u0163\3\2\2\2\u0175\u0164\3\2\2\2\u0175\u0169")
        buf.write("\3\2\2\2\u0175\u016f\3\2\2\2\u0176/\3\2\2\2\u0177\u0178")
        buf.write("\7#\2\2\u0178\u017a\7\65\2\2\u0179\u017b\5\64\33\2\u017a")
        buf.write("\u0179\3\2\2\2\u017b\u017c\3\2\2\2\u017c\u017a\3\2\2\2")
        buf.write("\u017c\u017d\3\2\2\2\u017d\u017e\3\2\2\2\u017e\u017f\7")
        buf.write("$\2\2\u017f\u0182\3\2\2\2\u0180\u0182\5\64\33\2\u0181")
        buf.write("\u0177\3\2\2\2\u0181\u0180\3\2\2\2\u0182\61\3\2\2\2\u0183")
        buf.write("\u0184\t\3\2\2\u0184\63\3\2\2\2\u0185\u0186\7#\2\2\u0186")
        buf.write("\u0187\5\62\32\2\u0187\u0188\7?\2\2\u0188\u0189\5.\30")
        buf.write("\2\u0189\u018a\7$\2\2\u018a\65\3\2\2\2\u018b\u018c\7=")
        buf.write("\2\2\u018c\67\3\2\2\2\u018d\u018e\7=\2\2\u018e9\3\2\2")
        buf.write("\2\u018f\u0190\7#\2\2\u0190\u0191\7\'\2\2\u0191\u0193")
        buf.write("\7\36\2\2\u0192\u0194\7=\2\2\u0193\u0192\3\2\2\2\u0194")
        buf.write("\u0195\3\2\2\2\u0195\u0193\3\2\2\2\u0195\u0196\3\2\2\2")
        buf.write("\u0196\u0197\3\2\2\2\u0197\u0198\7$\2\2\u0198;\3\2\2\2")
        buf.write("\u0199\u019a\7#\2\2\u019a\u019b\7\'\2\2\u019b\u019c\7")
        buf.write(" \2\2\u019c\u019d\5 \21\2\u019d\u019e\7$\2\2\u019e=\3")
        buf.write("\2\2\2\u019f\u01a0\7#\2\2\u01a0\u01a1\7\'\2\2\u01a1\u01a7")
        buf.write("\7\26\2\2\u01a2\u01a3\7#\2\2\u01a3\u01a4\5\b\5\2\u01a4")
        buf.write("\u01a5\7>\2\2\u01a5\u01a6\7$\2\2\u01a6\u01a8\3\2\2\2\u01a7")
        buf.write("\u01a2\3\2\2\2\u01a8\u01a9\3\2\2\2\u01a9\u01a7\3\2\2\2")
        buf.write("\u01a9\u01aa\3\2\2\2\u01aa\u01ab\3\2\2\2\u01ab\u01ac\7")
        buf.write("$\2\2\u01ac?\3\2\2\2\u01ad\u01ae\7#\2\2\u01ae\u01af\7")
        buf.write("\'\2\2\u01af\u01b3\7!\2\2\u01b0\u01b2\5B\"\2\u01b1\u01b0")
        buf.write("\3\2\2\2\u01b2\u01b5\3\2\2\2\u01b3\u01b1\3\2\2\2\u01b3")
        buf.write("\u01b4\3\2\2\2\u01b4\u01b6\3\2\2\2\u01b5\u01b3\3\2\2\2")
        buf.write("\u01b6\u01b7\7$\2\2\u01b7A\3\2\2\2\u01b8\u01b9\7#\2\2")
        buf.write("\u01b9\u01bd\5\22\n\2\u01ba\u01bc\5,\27\2\u01bb\u01ba")
        buf.write("\3\2\2\2\u01bc\u01bf\3\2\2\2\u01bd\u01bb\3\2\2\2\u01bd")
        buf.write("\u01be\3\2\2\2\u01be\u01c0\3\2\2\2\u01bf\u01bd\3\2\2\2")
        buf.write("\u01c0\u01c1\7$\2\2\u01c1\u01e1\3\2\2\2\u01c2\u01c3\7")
        buf.write("#\2\2\u01c3\u01c4\7/\2\2\u01c4\u01c5\5,\27\2\u01c5\u01c6")
        buf.write("\5,\27\2\u01c6\u01c7\7$\2\2\u01c7\u01e1\3\2\2\2\u01c8")
        buf.write("\u01c9\7#\2\2\u01c9\u01ca\7\61\2\2\u01ca\u01cb\5,\27\2")
        buf.write("\u01cb\u01cc\5,\27\2\u01cc\u01cd\7$\2\2\u01cd\u01e1\3")
        buf.write("\2\2\2\u01ce\u01cf\7#\2\2\u01cf\u01d0\7\62\2\2\u01d0\u01d1")
        buf.write("\5,\27\2\u01d1\u01d2\5,\27\2\u01d2\u01d3\7$\2\2\u01d3")
        buf.write("\u01e1\3\2\2\2\u01d4\u01d5\7#\2\2\u01d5\u01d6\7\63\2\2")
        buf.write("\u01d6\u01d7\5,\27\2\u01d7\u01d8\5,\27\2\u01d8\u01d9\7")
        buf.write("$\2\2\u01d9\u01e1\3\2\2\2\u01da\u01db\7#\2\2\u01db\u01dc")
        buf.write("\7\64\2\2\u01dc\u01dd\5,\27\2\u01dd\u01de\5,\27\2\u01de")
        buf.write("\u01df\7$\2\2\u01df\u01e1\3\2\2\2\u01e0\u01b8\3\2\2\2")
        buf.write("\u01e0\u01c2\3\2\2\2\u01e0\u01c8\3\2\2\2\u01e0\u01ce\3")
        buf.write("\2\2\2\u01e0\u01d4\3\2\2\2\u01e0\u01da\3\2\2\2\u01e1C")
        buf.write("\3\2\2\2#Paq\177\u0087\u0094\u00a2\u00a7\u00ac\u00b5\u00ba")
        buf.write("\u00bf\u00c5\u00cb\u00d0\u00d6\u00dc\u00e2\u00ea\u00f3")
        buf.write("\u0112\u0119\u0142\u014a\u015f\u0175\u017c\u0181\u0195")
        buf.write("\u01a9\u01b3\u01bd\u01e0")
        return buf.getvalue()


class Subtraction_GameParser ( Parser ):

    grammarFileName = "Subtraction_Game.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'domain'", "'problem'", "'define'", "'agentid'", 
                     "'constants'", "'type'", "'predicates'", "'action'", 
                     "'event'", "'events'", "'pldegree'", "'eventmodel'", 
                     "'parameters'", "'tercondition'", "'precondition'", 
                     "'response'", "'observation'", "'min'", "'max'", "'numbers'", 
                     "'normal'", "'miser'", "'effect'", "'object'", "'increase'", 
                     "'decrease'", "'assign'", "'agent'", "'either'", "'objects'", 
                     "'init'", "'goal'", "'('", "')'", "'['", "']'", "':'", 
                     "'?'", "'.'", "'_'", "'-'", "'+'", "'*'", "'/'", "'='", 
                     "'!='", "'<'", "'<='", "'>'", "'>='", "'and'", "'or'", 
                     "'not'", "'oneof'", "'imply'", "'forall'", "'exists'", 
                     "'when'" ]

    symbolicNames = [ "<INVALID>", "DOMAIN", "PROBLEM", "DEFINE", "AGENTID", 
                      "CONST", "TYPE", "PREDICATE", "ACTION", "EVENT", "EVENTS", 
                      "PLDEGREE", "EVENTMODEL", "PARAMETER", "TERCONDITION", 
                      "PRECONDITION", "RESPONSE", "OBSERVATION", "MIN", 
                      "MAX", "NUMS", "NORMAL", "MISER", "EFFECT", "OBJECT", 
                      "INC", "DEC", "ASSGIN", "AGENT", "EITHER", "OBJS", 
                      "INIT", "GOAL", "LB", "RB", "LSB", "RSB", "COLON", 
                      "QM", "POINT", "UL", "MINUS", "PLUS", "MULT", "DIV", 
                      "EQ", "NEQ", "LT", "LEQ", "GT", "GEQ", "AND", "OR", 
                      "NOT", "ONEOF", "IMPLY", "FORALL", "EXISTS", "WHEN", 
                      "NAME", "INTEGER", "VAR", "FUNSYM", "WS" ]

    RULE_domain = 0
    RULE_objectDefine = 1
    RULE_numericDefine = 2
    RULE_numericSymbol = 3
    RULE_typeDefine = 4
    RULE_terconditionDefine = 5
    RULE_predicateDefine = 6
    RULE_atomFormSkeleton = 7
    RULE_predicate = 8
    RULE_typeDeclaration = 9
    RULE_type = 10
    RULE_actionDefine = 11
    RULE_actionSymbol = 12
    RULE_emptyOrPreGD = 13
    RULE_emptyOrEffect = 14
    RULE_listName = 15
    RULE_listVariable = 16
    RULE_oneofDefine = 17
    RULE_gd = 18
    RULE_termAtomForm = 19
    RULE_termLiteral = 20
    RULE_constTerm = 21
    RULE_term = 22
    RULE_effect = 23
    RULE_assignop = 24
    RULE_pEffect = 25
    RULE_problemName = 26
    RULE_domainName = 27
    RULE_agentDefine = 28
    RULE_objectDeclaration = 29
    RULE_numericSetting = 30
    RULE_init = 31
    RULE_constTermAtomForm = 32

    ruleNames =  [ "domain", "objectDefine", "numericDefine", "numericSymbol", 
                   "typeDefine", "terconditionDefine", "predicateDefine", 
                   "atomFormSkeleton", "predicate", "typeDeclaration", "type", 
                   "actionDefine", "actionSymbol", "emptyOrPreGD", "emptyOrEffect", 
                   "listName", "listVariable", "oneofDefine", "gd", "termAtomForm", 
                   "termLiteral", "constTerm", "term", "effect", "assignop", 
                   "pEffect", "problemName", "domainName", "agentDefine", 
                   "objectDeclaration", "numericSetting", "init", "constTermAtomForm" ]

    EOF = Token.EOF
    DOMAIN=1
    PROBLEM=2
    DEFINE=3
    AGENTID=4
    CONST=5
    TYPE=6
    PREDICATE=7
    ACTION=8
    EVENT=9
    EVENTS=10
    PLDEGREE=11
    EVENTMODEL=12
    PARAMETER=13
    TERCONDITION=14
    PRECONDITION=15
    RESPONSE=16
    OBSERVATION=17
    MIN=18
    MAX=19
    NUMS=20
    NORMAL=21
    MISER=22
    EFFECT=23
    OBJECT=24
    INC=25
    DEC=26
    ASSGIN=27
    AGENT=28
    EITHER=29
    OBJS=30
    INIT=31
    GOAL=32
    LB=33
    RB=34
    LSB=35
    RSB=36
    COLON=37
    QM=38
    POINT=39
    UL=40
    MINUS=41
    PLUS=42
    MULT=43
    DIV=44
    EQ=45
    NEQ=46
    LT=47
    LEQ=48
    GT=49
    GEQ=50
    AND=51
    OR=52
    NOT=53
    ONEOF=54
    IMPLY=55
    FORALL=56
    EXISTS=57
    WHEN=58
    NAME=59
    INTEGER=60
    VAR=61
    FUNSYM=62
    WS=63

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class DomainContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.LB)
            else:
                return self.getToken(Subtraction_GameParser.LB, i)

        def DEFINE(self):
            return self.getToken(Subtraction_GameParser.DEFINE, 0)

        def DOMAIN(self):
            return self.getToken(Subtraction_GameParser.DOMAIN, 0)

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def RB(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.RB)
            else:
                return self.getToken(Subtraction_GameParser.RB, i)

        def objectDefine(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ObjectDefineContext,0)


        def typeDefine(self):
            return self.getTypedRuleContext(Subtraction_GameParser.TypeDefineContext,0)


        def terconditionDefine(self):
            return self.getTypedRuleContext(Subtraction_GameParser.TerconditionDefineContext,0)


        def actionDefine(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.ActionDefineContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.ActionDefineContext,i)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_domain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomain" ):
                listener.enterDomain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomain" ):
                listener.exitDomain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomain" ):
                return visitor.visitDomain(self)
            else:
                return visitor.visitChildren(self)




    def domain(self):

        localctx = Subtraction_GameParser.DomainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_domain)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self.match(Subtraction_GameParser.LB)
            self.state = 67
            self.match(Subtraction_GameParser.DEFINE)
            self.state = 68
            self.match(Subtraction_GameParser.LB)
            self.state = 69
            self.match(Subtraction_GameParser.DOMAIN)
            self.state = 70
            self.match(Subtraction_GameParser.NAME)
            self.state = 71
            self.match(Subtraction_GameParser.RB)
            self.state = 72
            self.objectDefine()
            self.state = 73
            self.typeDefine()
            self.state = 74
            self.terconditionDefine()
            self.state = 78
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==Subtraction_GameParser.LB:
                self.state = 75
                self.actionDefine()
                self.state = 80
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 81
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ObjectDefineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def OBJS(self):
            return self.getToken(Subtraction_GameParser.OBJS, 0)

        def listVariable(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ListVariableContext,0)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_objectDefine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectDefine" ):
                listener.enterObjectDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectDefine" ):
                listener.exitObjectDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectDefine" ):
                return visitor.visitObjectDefine(self)
            else:
                return visitor.visitChildren(self)




    def objectDefine(self):

        localctx = Subtraction_GameParser.ObjectDefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_objectDefine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.match(Subtraction_GameParser.LB)
            self.state = 84
            self.match(Subtraction_GameParser.COLON)
            self.state = 85
            self.match(Subtraction_GameParser.OBJS)
            self.state = 86
            self.listVariable()
            self.state = 87
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumericDefineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def NUMS(self):
            return self.getToken(Subtraction_GameParser.NUMS, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def numericSymbol(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.NumericSymbolContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.NumericSymbolContext,i)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_numericDefine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericDefine" ):
                listener.enterNumericDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericDefine" ):
                listener.exitNumericDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericDefine" ):
                return visitor.visitNumericDefine(self)
            else:
                return visitor.visitChildren(self)




    def numericDefine(self):

        localctx = Subtraction_GameParser.NumericDefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_numericDefine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            self.match(Subtraction_GameParser.LB)
            self.state = 90
            self.match(Subtraction_GameParser.COLON)
            self.state = 91
            self.match(Subtraction_GameParser.NUMS)
            self.state = 93 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 92
                self.numericSymbol()
                self.state = 95 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==Subtraction_GameParser.NAME):
                    break

            self.state = 97
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumericSymbolContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_numericSymbol

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericSymbol" ):
                listener.enterNumericSymbol(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericSymbol" ):
                listener.exitNumericSymbol(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericSymbol" ):
                return visitor.visitNumericSymbol(self)
            else:
                return visitor.visitChildren(self)




    def numericSymbol(self):

        localctx = Subtraction_GameParser.NumericSymbolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_numericSymbol)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(Subtraction_GameParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeDefineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def TYPE(self):
            return self.getToken(Subtraction_GameParser.TYPE, 0)

        def NORMAL(self):
            return self.getToken(Subtraction_GameParser.NORMAL, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def MISER(self):
            return self.getToken(Subtraction_GameParser.MISER, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_typeDefine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDefine" ):
                listener.enterTypeDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDefine" ):
                listener.exitTypeDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDefine" ):
                return visitor.visitTypeDefine(self)
            else:
                return visitor.visitChildren(self)




    def typeDefine(self):

        localctx = Subtraction_GameParser.TypeDefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_typeDefine)
        try:
            self.state = 111
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 101
                self.match(Subtraction_GameParser.LB)
                self.state = 102
                self.match(Subtraction_GameParser.COLON)
                self.state = 103
                self.match(Subtraction_GameParser.TYPE)
                self.state = 104
                self.match(Subtraction_GameParser.NORMAL)
                self.state = 105
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 106
                self.match(Subtraction_GameParser.LB)
                self.state = 107
                self.match(Subtraction_GameParser.COLON)
                self.state = 108
                self.match(Subtraction_GameParser.TYPE)
                self.state = 109
                self.match(Subtraction_GameParser.MISER)
                self.state = 110
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TerconditionDefineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def TERCONDITION(self):
            return self.getToken(Subtraction_GameParser.TERCONDITION, 0)

        def emptyOrPreGD(self):
            return self.getTypedRuleContext(Subtraction_GameParser.EmptyOrPreGDContext,0)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_terconditionDefine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerconditionDefine" ):
                listener.enterTerconditionDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerconditionDefine" ):
                listener.exitTerconditionDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerconditionDefine" ):
                return visitor.visitTerconditionDefine(self)
            else:
                return visitor.visitChildren(self)




    def terconditionDefine(self):

        localctx = Subtraction_GameParser.TerconditionDefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_terconditionDefine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.match(Subtraction_GameParser.LB)
            self.state = 114
            self.match(Subtraction_GameParser.COLON)
            self.state = 115
            self.match(Subtraction_GameParser.TERCONDITION)
            self.state = 116
            self.emptyOrPreGD()
            self.state = 117
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PredicateDefineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def PREDICATE(self):
            return self.getToken(Subtraction_GameParser.PREDICATE, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def atomFormSkeleton(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.AtomFormSkeletonContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.AtomFormSkeletonContext,i)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_predicateDefine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateDefine" ):
                listener.enterPredicateDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateDefine" ):
                listener.exitPredicateDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateDefine" ):
                return visitor.visitPredicateDefine(self)
            else:
                return visitor.visitChildren(self)




    def predicateDefine(self):

        localctx = Subtraction_GameParser.PredicateDefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_predicateDefine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(Subtraction_GameParser.LB)
            self.state = 120
            self.match(Subtraction_GameParser.COLON)
            self.state = 121
            self.match(Subtraction_GameParser.PREDICATE)
            self.state = 123 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 122
                self.atomFormSkeleton()
                self.state = 125 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==Subtraction_GameParser.LB):
                    break

            self.state = 127
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomFormSkeletonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def predicate(self):
            return self.getTypedRuleContext(Subtraction_GameParser.PredicateContext,0)


        def listVariable(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ListVariableContext,0)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def oneofDefine(self):
            return self.getTypedRuleContext(Subtraction_GameParser.OneofDefineContext,0)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_atomFormSkeleton

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomFormSkeleton" ):
                listener.enterAtomFormSkeleton(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomFormSkeleton" ):
                listener.exitAtomFormSkeleton(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomFormSkeleton" ):
                return visitor.visitAtomFormSkeleton(self)
            else:
                return visitor.visitChildren(self)




    def atomFormSkeleton(self):

        localctx = Subtraction_GameParser.AtomFormSkeletonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_atomFormSkeleton)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(Subtraction_GameParser.LB)
            self.state = 130
            self.predicate()
            self.state = 131
            self.listVariable()
            self.state = 133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==Subtraction_GameParser.ONEOF:
                self.state = 132
                self.oneofDefine()


            self.state = 135
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = Subtraction_GameParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(Subtraction_GameParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeDeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def constTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.ConstTermContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.ConstTermContext,i)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_typeDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclaration" ):
                listener.enterTypeDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclaration" ):
                listener.exitTypeDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclaration" ):
                return visitor.visitTypeDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclaration(self):

        localctx = Subtraction_GameParser.TypeDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_typeDeclaration)
        try:
            self.state = 146
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [Subtraction_GameParser.NAME]:
                self.enterOuterAlt(localctx, 1)
                self.state = 139
                self.match(Subtraction_GameParser.NAME)
                pass
            elif token in [Subtraction_GameParser.LB]:
                self.enterOuterAlt(localctx, 2)
                self.state = 140
                self.match(Subtraction_GameParser.LB)
                self.state = 141
                self.match(Subtraction_GameParser.NAME)
                self.state = 142
                self.constTerm()
                self.state = 143
                self.constTerm()
                self.state = 144
                self.match(Subtraction_GameParser.RB)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OBJECT(self):
            return self.getToken(Subtraction_GameParser.OBJECT, 0)

        def AGENT(self):
            return self.getToken(Subtraction_GameParser.AGENT, 0)

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType" ):
                return visitor.visitType(self)
            else:
                return visitor.visitChildren(self)




    def type(self):

        localctx = Subtraction_GameParser.TypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << Subtraction_GameParser.OBJECT) | (1 << Subtraction_GameParser.AGENT) | (1 << Subtraction_GameParser.NAME))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ActionDefineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.LB)
            else:
                return self.getToken(Subtraction_GameParser.LB, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.COLON)
            else:
                return self.getToken(Subtraction_GameParser.COLON, i)

        def ACTION(self):
            return self.getToken(Subtraction_GameParser.ACTION, 0)

        def actionSymbol(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ActionSymbolContext,0)


        def RB(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.RB)
            else:
                return self.getToken(Subtraction_GameParser.RB, i)

        def PARAMETER(self):
            return self.getToken(Subtraction_GameParser.PARAMETER, 0)

        def listVariable(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ListVariableContext,0)


        def PRECONDITION(self):
            return self.getToken(Subtraction_GameParser.PRECONDITION, 0)

        def emptyOrPreGD(self):
            return self.getTypedRuleContext(Subtraction_GameParser.EmptyOrPreGDContext,0)


        def EFFECT(self):
            return self.getToken(Subtraction_GameParser.EFFECT, 0)

        def emptyOrEffect(self):
            return self.getTypedRuleContext(Subtraction_GameParser.EmptyOrEffectContext,0)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_actionDefine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionDefine" ):
                listener.enterActionDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionDefine" ):
                listener.exitActionDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActionDefine" ):
                return visitor.visitActionDefine(self)
            else:
                return visitor.visitChildren(self)




    def actionDefine(self):

        localctx = Subtraction_GameParser.ActionDefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_actionDefine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(Subtraction_GameParser.LB)
            self.state = 151
            self.match(Subtraction_GameParser.COLON)
            self.state = 152
            self.match(Subtraction_GameParser.ACTION)
            self.state = 153
            self.actionSymbol()
            self.state = 160
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.state = 154
                self.match(Subtraction_GameParser.COLON)
                self.state = 155
                self.match(Subtraction_GameParser.PARAMETER)
                self.state = 156
                self.match(Subtraction_GameParser.LB)
                self.state = 157
                self.listVariable()
                self.state = 158
                self.match(Subtraction_GameParser.RB)


            self.state = 165
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 162
                self.match(Subtraction_GameParser.COLON)
                self.state = 163
                self.match(Subtraction_GameParser.PRECONDITION)
                self.state = 164
                self.emptyOrPreGD()


            self.state = 170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==Subtraction_GameParser.COLON:
                self.state = 167
                self.match(Subtraction_GameParser.COLON)
                self.state = 168
                self.match(Subtraction_GameParser.EFFECT)
                self.state = 169
                self.emptyOrEffect()


            self.state = 172
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ActionSymbolContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_actionSymbol

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionSymbol" ):
                listener.enterActionSymbol(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionSymbol" ):
                listener.exitActionSymbol(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActionSymbol" ):
                return visitor.visitActionSymbol(self)
            else:
                return visitor.visitChildren(self)




    def actionSymbol(self):

        localctx = Subtraction_GameParser.ActionSymbolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_actionSymbol)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(Subtraction_GameParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EmptyOrPreGDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gd(self):
            return self.getTypedRuleContext(Subtraction_GameParser.GdContext,0)


        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_emptyOrPreGD

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyOrPreGD" ):
                listener.enterEmptyOrPreGD(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyOrPreGD" ):
                listener.exitEmptyOrPreGD(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmptyOrPreGD" ):
                return visitor.visitEmptyOrPreGD(self)
            else:
                return visitor.visitChildren(self)




    def emptyOrPreGD(self):

        localctx = Subtraction_GameParser.EmptyOrPreGDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_emptyOrPreGD)
        try:
            self.state = 179
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 176
                self.gd()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 177
                self.match(Subtraction_GameParser.LB)
                self.state = 178
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EmptyOrEffectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def effect(self):
            return self.getTypedRuleContext(Subtraction_GameParser.EffectContext,0)


        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_emptyOrEffect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyOrEffect" ):
                listener.enterEmptyOrEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyOrEffect" ):
                listener.exitEmptyOrEffect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmptyOrEffect" ):
                return visitor.visitEmptyOrEffect(self)
            else:
                return visitor.visitChildren(self)




    def emptyOrEffect(self):

        localctx = Subtraction_GameParser.EmptyOrEffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_emptyOrEffect)
        try:
            self.state = 184
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 181
                self.effect()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 182
                self.match(Subtraction_GameParser.LB)
                self.state = 183
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.NAME)
            else:
                return self.getToken(Subtraction_GameParser.NAME, i)

        def MINUS(self):
            return self.getToken(Subtraction_GameParser.MINUS, 0)

        def type(self):
            return self.getTypedRuleContext(Subtraction_GameParser.TypeContext,0)


        def listName(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ListNameContext,0)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_listName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListName" ):
                listener.enterListName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListName" ):
                listener.exitListName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListName" ):
                return visitor.visitListName(self)
            else:
                return visitor.visitChildren(self)




    def listName(self):

        localctx = Subtraction_GameParser.ListNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_listName)
        self._la = 0 # Token type
        try:
            self.state = 201
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 189
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==Subtraction_GameParser.NAME:
                    self.state = 186
                    self.match(Subtraction_GameParser.NAME)
                    self.state = 191
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 193 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 192
                    self.match(Subtraction_GameParser.NAME)
                    self.state = 195 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==Subtraction_GameParser.NAME):
                        break

                self.state = 197
                self.match(Subtraction_GameParser.MINUS)
                self.state = 198
                self.type()
                self.state = 199
                self.listName()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListVariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.VAR)
            else:
                return self.getToken(Subtraction_GameParser.VAR, i)

        def MINUS(self):
            return self.getToken(Subtraction_GameParser.MINUS, 0)

        def type(self):
            return self.getTypedRuleContext(Subtraction_GameParser.TypeContext,0)


        def listVariable(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ListVariableContext,0)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_listVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListVariable" ):
                listener.enterListVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListVariable" ):
                listener.exitListVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListVariable" ):
                return visitor.visitListVariable(self)
            else:
                return visitor.visitChildren(self)




    def listVariable(self):

        localctx = Subtraction_GameParser.ListVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_listVariable)
        self._la = 0 # Token type
        try:
            self.state = 218
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 206
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==Subtraction_GameParser.VAR:
                    self.state = 203
                    self.match(Subtraction_GameParser.VAR)
                    self.state = 208
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 210 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 209
                    self.match(Subtraction_GameParser.VAR)
                    self.state = 212 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==Subtraction_GameParser.VAR):
                        break

                self.state = 214
                self.match(Subtraction_GameParser.MINUS)
                self.state = 215
                self.type()
                self.state = 216
                self.listVariable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OneofDefineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONEOF(self):
            return self.getToken(Subtraction_GameParser.ONEOF, 0)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.VAR)
            else:
                return self.getToken(Subtraction_GameParser.VAR, i)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_oneofDefine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOneofDefine" ):
                listener.enterOneofDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOneofDefine" ):
                listener.exitOneofDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOneofDefine" ):
                return visitor.visitOneofDefine(self)
            else:
                return visitor.visitChildren(self)




    def oneofDefine(self):

        localctx = Subtraction_GameParser.OneofDefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_oneofDefine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 220
            self.match(Subtraction_GameParser.ONEOF)
            self.state = 222 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 221
                self.match(Subtraction_GameParser.VAR)
                self.state = 224 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==Subtraction_GameParser.VAR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GdContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def termAtomForm(self):
            return self.getTypedRuleContext(Subtraction_GameParser.TermAtomFormContext,0)


        def LB(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.LB)
            else:
                return self.getToken(Subtraction_GameParser.LB, i)

        def AND(self):
            return self.getToken(Subtraction_GameParser.AND, 0)

        def RB(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.RB)
            else:
                return self.getToken(Subtraction_GameParser.RB, i)

        def gd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.GdContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.GdContext,i)


        def OR(self):
            return self.getToken(Subtraction_GameParser.OR, 0)

        def NOT(self):
            return self.getToken(Subtraction_GameParser.NOT, 0)

        def IMPLY(self):
            return self.getToken(Subtraction_GameParser.IMPLY, 0)

        def EXISTS(self):
            return self.getToken(Subtraction_GameParser.EXISTS, 0)

        def listVariable(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ListVariableContext,0)


        def FORALL(self):
            return self.getToken(Subtraction_GameParser.FORALL, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_gd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGd" ):
                listener.enterGd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGd" ):
                listener.exitGd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGd" ):
                return visitor.visitGd(self)
            else:
                return visitor.visitChildren(self)




    def gd(self):

        localctx = Subtraction_GameParser.GdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_gd)
        self._la = 0 # Token type
        try:
            self.state = 272
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 226
                self.termAtomForm()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 227
                self.match(Subtraction_GameParser.LB)
                self.state = 228
                self.match(Subtraction_GameParser.AND)
                self.state = 230 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 229
                    self.gd()
                    self.state = 232 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==Subtraction_GameParser.LB):
                        break

                self.state = 234
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 236
                self.match(Subtraction_GameParser.LB)
                self.state = 237
                self.match(Subtraction_GameParser.OR)
                self.state = 239 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 238
                    self.gd()
                    self.state = 241 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==Subtraction_GameParser.LB):
                        break

                self.state = 243
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 245
                self.match(Subtraction_GameParser.LB)
                self.state = 246
                self.match(Subtraction_GameParser.NOT)
                self.state = 247
                self.gd()
                self.state = 248
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 250
                self.match(Subtraction_GameParser.LB)
                self.state = 251
                self.match(Subtraction_GameParser.IMPLY)
                self.state = 252
                self.gd()
                self.state = 253
                self.gd()
                self.state = 254
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 256
                self.match(Subtraction_GameParser.LB)
                self.state = 257
                self.match(Subtraction_GameParser.EXISTS)
                self.state = 258
                self.match(Subtraction_GameParser.LB)
                self.state = 259
                self.listVariable()
                self.state = 260
                self.match(Subtraction_GameParser.RB)
                self.state = 261
                self.gd()
                self.state = 262
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 264
                self.match(Subtraction_GameParser.LB)
                self.state = 265
                self.match(Subtraction_GameParser.FORALL)
                self.state = 266
                self.match(Subtraction_GameParser.LB)
                self.state = 267
                self.listVariable()
                self.state = 268
                self.match(Subtraction_GameParser.RB)
                self.state = 269
                self.gd()
                self.state = 270
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermAtomFormContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def predicate(self):
            return self.getTypedRuleContext(Subtraction_GameParser.PredicateContext,0)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.TermContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.TermContext,i)


        def EQ(self):
            return self.getToken(Subtraction_GameParser.EQ, 0)

        def NEQ(self):
            return self.getToken(Subtraction_GameParser.NEQ, 0)

        def LT(self):
            return self.getToken(Subtraction_GameParser.LT, 0)

        def LEQ(self):
            return self.getToken(Subtraction_GameParser.LEQ, 0)

        def GT(self):
            return self.getToken(Subtraction_GameParser.GT, 0)

        def GEQ(self):
            return self.getToken(Subtraction_GameParser.GEQ, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_termAtomForm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermAtomForm" ):
                listener.enterTermAtomForm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermAtomForm" ):
                listener.exitTermAtomForm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTermAtomForm" ):
                return visitor.visitTermAtomForm(self)
            else:
                return visitor.visitChildren(self)




    def termAtomForm(self):

        localctx = Subtraction_GameParser.TermAtomFormContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_termAtomForm)
        self._la = 0 # Token type
        try:
            self.state = 320
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 274
                self.match(Subtraction_GameParser.LB)
                self.state = 275
                self.predicate()
                self.state = 279
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << Subtraction_GameParser.LB) | (1 << Subtraction_GameParser.NAME) | (1 << Subtraction_GameParser.INTEGER) | (1 << Subtraction_GameParser.VAR))) != 0):
                    self.state = 276
                    self.term()
                    self.state = 281
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 282
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 284
                self.match(Subtraction_GameParser.LB)
                self.state = 285
                self.match(Subtraction_GameParser.EQ)
                self.state = 286
                self.term()
                self.state = 287
                self.term()
                self.state = 288
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 290
                self.match(Subtraction_GameParser.LB)
                self.state = 291
                self.match(Subtraction_GameParser.NEQ)
                self.state = 292
                self.term()
                self.state = 293
                self.term()
                self.state = 294
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 296
                self.match(Subtraction_GameParser.LB)
                self.state = 297
                self.match(Subtraction_GameParser.LT)
                self.state = 298
                self.term()
                self.state = 299
                self.term()
                self.state = 300
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 302
                self.match(Subtraction_GameParser.LB)
                self.state = 303
                self.match(Subtraction_GameParser.LEQ)
                self.state = 304
                self.term()
                self.state = 305
                self.term()
                self.state = 306
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 308
                self.match(Subtraction_GameParser.LB)
                self.state = 309
                self.match(Subtraction_GameParser.GT)
                self.state = 310
                self.term()
                self.state = 311
                self.term()
                self.state = 312
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 314
                self.match(Subtraction_GameParser.LB)
                self.state = 315
                self.match(Subtraction_GameParser.GEQ)
                self.state = 316
                self.term()
                self.state = 317
                self.term()
                self.state = 318
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def termAtomForm(self):
            return self.getTypedRuleContext(Subtraction_GameParser.TermAtomFormContext,0)


        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def NOT(self):
            return self.getToken(Subtraction_GameParser.NOT, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_termLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTermLiteral" ):
                listener.enterTermLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTermLiteral" ):
                listener.exitTermLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTermLiteral" ):
                return visitor.visitTermLiteral(self)
            else:
                return visitor.visitChildren(self)




    def termLiteral(self):

        localctx = Subtraction_GameParser.TermLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_termLiteral)
        try:
            self.state = 328
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 322
                self.termAtomForm()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 323
                self.match(Subtraction_GameParser.LB)
                self.state = 324
                self.match(Subtraction_GameParser.NOT)
                self.state = 325
                self.termAtomForm()
                self.state = 326
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstTermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def INTEGER(self):
            return self.getToken(Subtraction_GameParser.INTEGER, 0)

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def MINUS(self):
            return self.getToken(Subtraction_GameParser.MINUS, 0)

        def constTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.ConstTermContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.ConstTermContext,i)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def PLUS(self):
            return self.getToken(Subtraction_GameParser.PLUS, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_constTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstTerm" ):
                listener.enterConstTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstTerm" ):
                listener.exitConstTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstTerm" ):
                return visitor.visitConstTerm(self)
            else:
                return visitor.visitChildren(self)




    def constTerm(self):

        localctx = Subtraction_GameParser.ConstTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_constTerm)
        try:
            self.state = 349
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 330
                self.match(Subtraction_GameParser.NAME)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 331
                self.match(Subtraction_GameParser.INTEGER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 332
                self.match(Subtraction_GameParser.LB)
                self.state = 333
                self.match(Subtraction_GameParser.MINUS)
                self.state = 334
                self.constTerm()
                self.state = 335
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 337
                self.match(Subtraction_GameParser.LB)
                self.state = 338
                self.match(Subtraction_GameParser.MINUS)
                self.state = 339
                self.constTerm()
                self.state = 340
                self.constTerm()
                self.state = 341
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 343
                self.match(Subtraction_GameParser.LB)
                self.state = 344
                self.match(Subtraction_GameParser.PLUS)
                self.state = 345
                self.constTerm()
                self.state = 346
                self.constTerm()
                self.state = 347
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def VAR(self):
            return self.getToken(Subtraction_GameParser.VAR, 0)

        def INTEGER(self):
            return self.getToken(Subtraction_GameParser.INTEGER, 0)

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def MINUS(self):
            return self.getToken(Subtraction_GameParser.MINUS, 0)

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.TermContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.TermContext,i)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def PLUS(self):
            return self.getToken(Subtraction_GameParser.PLUS, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)




    def term(self):

        localctx = Subtraction_GameParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_term)
        try:
            self.state = 371
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 351
                self.match(Subtraction_GameParser.NAME)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 352
                self.match(Subtraction_GameParser.VAR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 353
                self.match(Subtraction_GameParser.INTEGER)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 354
                self.match(Subtraction_GameParser.LB)
                self.state = 355
                self.match(Subtraction_GameParser.MINUS)
                self.state = 356
                self.term()
                self.state = 357
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 359
                self.match(Subtraction_GameParser.LB)
                self.state = 360
                self.match(Subtraction_GameParser.MINUS)
                self.state = 361
                self.term()
                self.state = 362
                self.term()
                self.state = 363
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 365
                self.match(Subtraction_GameParser.LB)
                self.state = 366
                self.match(Subtraction_GameParser.PLUS)
                self.state = 367
                self.term()
                self.state = 368
                self.term()
                self.state = 369
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EffectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def AND(self):
            return self.getToken(Subtraction_GameParser.AND, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def pEffect(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.PEffectContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.PEffectContext,i)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_effect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEffect" ):
                listener.enterEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEffect" ):
                listener.exitEffect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEffect" ):
                return visitor.visitEffect(self)
            else:
                return visitor.visitChildren(self)




    def effect(self):

        localctx = Subtraction_GameParser.EffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_effect)
        self._la = 0 # Token type
        try:
            self.state = 383
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 373
                self.match(Subtraction_GameParser.LB)
                self.state = 374
                self.match(Subtraction_GameParser.AND)
                self.state = 376 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 375
                    self.pEffect()
                    self.state = 378 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==Subtraction_GameParser.LB):
                        break

                self.state = 380
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 382
                self.pEffect()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INC(self):
            return self.getToken(Subtraction_GameParser.INC, 0)

        def DEC(self):
            return self.getToken(Subtraction_GameParser.DEC, 0)

        def ASSGIN(self):
            return self.getToken(Subtraction_GameParser.ASSGIN, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_assignop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignop" ):
                listener.enterAssignop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignop" ):
                listener.exitAssignop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignop" ):
                return visitor.visitAssignop(self)
            else:
                return visitor.visitChildren(self)




    def assignop(self):

        localctx = Subtraction_GameParser.AssignopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_assignop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << Subtraction_GameParser.INC) | (1 << Subtraction_GameParser.DEC) | (1 << Subtraction_GameParser.ASSGIN))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PEffectContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def assignop(self):
            return self.getTypedRuleContext(Subtraction_GameParser.AssignopContext,0)


        def VAR(self):
            return self.getToken(Subtraction_GameParser.VAR, 0)

        def term(self):
            return self.getTypedRuleContext(Subtraction_GameParser.TermContext,0)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_pEffect

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPEffect" ):
                listener.enterPEffect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPEffect" ):
                listener.exitPEffect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPEffect" ):
                return visitor.visitPEffect(self)
            else:
                return visitor.visitChildren(self)




    def pEffect(self):

        localctx = Subtraction_GameParser.PEffectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_pEffect)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(Subtraction_GameParser.LB)
            self.state = 388
            self.assignop()
            self.state = 389
            self.match(Subtraction_GameParser.VAR)
            self.state = 390
            self.term()
            self.state = 391
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProblemNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_problemName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProblemName" ):
                listener.enterProblemName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProblemName" ):
                listener.exitProblemName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProblemName" ):
                return visitor.visitProblemName(self)
            else:
                return visitor.visitChildren(self)




    def problemName(self):

        localctx = Subtraction_GameParser.ProblemNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_problemName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 393
            self.match(Subtraction_GameParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DomainNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(Subtraction_GameParser.NAME, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_domainName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomainName" ):
                listener.enterDomainName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomainName" ):
                listener.exitDomainName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDomainName" ):
                return visitor.visitDomainName(self)
            else:
                return visitor.visitChildren(self)




    def domainName(self):

        localctx = Subtraction_GameParser.DomainNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_domainName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 395
            self.match(Subtraction_GameParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AgentDefineContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def AGENT(self):
            return self.getToken(Subtraction_GameParser.AGENT, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def NAME(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.NAME)
            else:
                return self.getToken(Subtraction_GameParser.NAME, i)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_agentDefine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgentDefine" ):
                listener.enterAgentDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgentDefine" ):
                listener.exitAgentDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAgentDefine" ):
                return visitor.visitAgentDefine(self)
            else:
                return visitor.visitChildren(self)




    def agentDefine(self):

        localctx = Subtraction_GameParser.AgentDefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_agentDefine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self.match(Subtraction_GameParser.LB)
            self.state = 398
            self.match(Subtraction_GameParser.COLON)
            self.state = 399
            self.match(Subtraction_GameParser.AGENT)
            self.state = 401 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 400
                self.match(Subtraction_GameParser.NAME)
                self.state = 403 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==Subtraction_GameParser.NAME):
                    break

            self.state = 405
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ObjectDeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def OBJS(self):
            return self.getToken(Subtraction_GameParser.OBJS, 0)

        def listName(self):
            return self.getTypedRuleContext(Subtraction_GameParser.ListNameContext,0)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_objectDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectDeclaration" ):
                listener.enterObjectDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectDeclaration" ):
                listener.exitObjectDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectDeclaration" ):
                return visitor.visitObjectDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def objectDeclaration(self):

        localctx = Subtraction_GameParser.ObjectDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_objectDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 407
            self.match(Subtraction_GameParser.LB)
            self.state = 408
            self.match(Subtraction_GameParser.COLON)
            self.state = 409
            self.match(Subtraction_GameParser.OBJS)
            self.state = 410
            self.listName()
            self.state = 411
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumericSettingContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.LB)
            else:
                return self.getToken(Subtraction_GameParser.LB, i)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def NUMS(self):
            return self.getToken(Subtraction_GameParser.NUMS, 0)

        def RB(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.RB)
            else:
                return self.getToken(Subtraction_GameParser.RB, i)

        def numericSymbol(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.NumericSymbolContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.NumericSymbolContext,i)


        def INTEGER(self, i:int=None):
            if i is None:
                return self.getTokens(Subtraction_GameParser.INTEGER)
            else:
                return self.getToken(Subtraction_GameParser.INTEGER, i)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_numericSetting

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericSetting" ):
                listener.enterNumericSetting(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericSetting" ):
                listener.exitNumericSetting(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericSetting" ):
                return visitor.visitNumericSetting(self)
            else:
                return visitor.visitChildren(self)




    def numericSetting(self):

        localctx = Subtraction_GameParser.NumericSettingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_numericSetting)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self.match(Subtraction_GameParser.LB)
            self.state = 414
            self.match(Subtraction_GameParser.COLON)
            self.state = 415
            self.match(Subtraction_GameParser.NUMS)
            self.state = 421 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 416
                self.match(Subtraction_GameParser.LB)
                self.state = 417
                self.numericSymbol()
                self.state = 418
                self.match(Subtraction_GameParser.INTEGER)
                self.state = 419
                self.match(Subtraction_GameParser.RB)
                self.state = 423 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==Subtraction_GameParser.LB):
                    break

            self.state = 425
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def COLON(self):
            return self.getToken(Subtraction_GameParser.COLON, 0)

        def INIT(self):
            return self.getToken(Subtraction_GameParser.INIT, 0)

        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def constTermAtomForm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.ConstTermAtomFormContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.ConstTermAtomFormContext,i)


        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_init

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInit" ):
                listener.enterInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInit" ):
                listener.exitInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInit" ):
                return visitor.visitInit(self)
            else:
                return visitor.visitChildren(self)




    def init(self):

        localctx = Subtraction_GameParser.InitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_init)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 427
            self.match(Subtraction_GameParser.LB)
            self.state = 428
            self.match(Subtraction_GameParser.COLON)
            self.state = 429
            self.match(Subtraction_GameParser.INIT)
            self.state = 433
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==Subtraction_GameParser.LB:
                self.state = 430
                self.constTermAtomForm()
                self.state = 435
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 436
            self.match(Subtraction_GameParser.RB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstTermAtomFormContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LB(self):
            return self.getToken(Subtraction_GameParser.LB, 0)

        def predicate(self):
            return self.getTypedRuleContext(Subtraction_GameParser.PredicateContext,0)


        def RB(self):
            return self.getToken(Subtraction_GameParser.RB, 0)

        def constTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(Subtraction_GameParser.ConstTermContext)
            else:
                return self.getTypedRuleContext(Subtraction_GameParser.ConstTermContext,i)


        def EQ(self):
            return self.getToken(Subtraction_GameParser.EQ, 0)

        def LT(self):
            return self.getToken(Subtraction_GameParser.LT, 0)

        def LEQ(self):
            return self.getToken(Subtraction_GameParser.LEQ, 0)

        def GT(self):
            return self.getToken(Subtraction_GameParser.GT, 0)

        def GEQ(self):
            return self.getToken(Subtraction_GameParser.GEQ, 0)

        def getRuleIndex(self):
            return Subtraction_GameParser.RULE_constTermAtomForm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstTermAtomForm" ):
                listener.enterConstTermAtomForm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstTermAtomForm" ):
                listener.exitConstTermAtomForm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstTermAtomForm" ):
                return visitor.visitConstTermAtomForm(self)
            else:
                return visitor.visitChildren(self)




    def constTermAtomForm(self):

        localctx = Subtraction_GameParser.ConstTermAtomFormContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_constTermAtomForm)
        self._la = 0 # Token type
        try:
            self.state = 478
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 438
                self.match(Subtraction_GameParser.LB)
                self.state = 439
                self.predicate()
                self.state = 443
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << Subtraction_GameParser.LB) | (1 << Subtraction_GameParser.NAME) | (1 << Subtraction_GameParser.INTEGER))) != 0):
                    self.state = 440
                    self.constTerm()
                    self.state = 445
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 446
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 448
                self.match(Subtraction_GameParser.LB)
                self.state = 449
                self.match(Subtraction_GameParser.EQ)
                self.state = 450
                self.constTerm()
                self.state = 451
                self.constTerm()
                self.state = 452
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 454
                self.match(Subtraction_GameParser.LB)
                self.state = 455
                self.match(Subtraction_GameParser.LT)
                self.state = 456
                self.constTerm()
                self.state = 457
                self.constTerm()
                self.state = 458
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 460
                self.match(Subtraction_GameParser.LB)
                self.state = 461
                self.match(Subtraction_GameParser.LEQ)
                self.state = 462
                self.constTerm()
                self.state = 463
                self.constTerm()
                self.state = 464
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 466
                self.match(Subtraction_GameParser.LB)
                self.state = 467
                self.match(Subtraction_GameParser.GT)
                self.state = 468
                self.constTerm()
                self.state = 469
                self.constTerm()
                self.state = 470
                self.match(Subtraction_GameParser.RB)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 472
                self.match(Subtraction_GameParser.LB)
                self.state = 473
                self.match(Subtraction_GameParser.GEQ)
                self.state = 474
                self.constTerm()
                self.state = 475
                self.constTerm()
                self.state = 476
                self.match(Subtraction_GameParser.RB)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





